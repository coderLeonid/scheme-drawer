/*Массивы динамические двумерные
 Сортировка элементов всех строк двумерного массива
 по убыванию методом обмена с флагом перестановки*.*/
#include<iostream>
#include <locale.h>
using namespace std;
typedef int num;		//определение типа значений элементов массива
typedef num* strin;		//определение типа "указатель на num"
typedef strin* matrix;	//определение типа "указатель на указатель на num"
void inputmatr(matrix a, int str, int sto);
void outputmatr(matrix a, int str, int sto);
void sort_obmenF(matrix a, int str, int sto);
void null_elems_out_of_zone(matrix a, int str, int sto);

int main()
{
	int i;
	int n;		//число строк матрицы
	int m;		//число столбцов матрицы
	matrix a;	//объявляется переменная-указатель на указатель на num
	setlocale(LC_ALL, "Russian");
	cout << " Введите количество строк и столбцов матрицы: ";
	cin >> n >> m;
	if (n != m || n % 2 != 0) {
		cout << " Матрица не является квадратной с чётным количеством строк!\n";
		cout << " Повторить-1, Выход-2: ";
		cin >> i;
		cout << endl;
		if (i == 1) main();
		return 0;
	}
	a = new strin[n];		//выделение динамической памяти под массив
	//указателей на строки массива.
	for (i = 0; i < n; i++) 	//Цикл выделения памяти под каждую строку.
		*(a + i) = new num[m];	//Каждому элементу массива указателей
	//на строки присваивается адрес начала
	//области памяти, выделяемой под строку
	inputmatr(a, n, m);
	cout << " Исходная матрица:\n";
	outputmatr(a, n, m);
	sort_obmenF(a, n, m);
	null_elems_out_of_zone(a, n, m);
	cout << " Матрица с отсортированными столбцами и обнулёнными элементами вне области сортировки:" << endl;
	outputmatr(a, n, m);
	//Освобождение динамической памяти
	for (i = 0; i < n; i++) delete a[i];
	delete a;

	cout << " Повторить-1, Выход-2: ";
	cin >> i;
	cout << endl;
	if (i == 1) main();
	return 0;
}

void inputmatr(matrix a, int str, int sto)
{
	cout << " Введите построчно через пробел элементы" << endl;
	cout << " двумерного массива размера " << str << "x" << sto << endl;
	cout << " После ввода строки нажимайте <Enter>" << endl;
	for (int i = 0; i < str; i++)
		for (int j = 0; j < sto; j++)
			*(*(a + i) + j) = (str * sto - 1) - (sto * i + j);	//на этапе тестирования происходит
	//автоматическое заполнение значений
	//элементов массива
}

void null_elems_out_of_zone(matrix a, int str, int sto) {
	int i, j, k, mn, indent_min, indent_max;
	num z;
	for (j = 0; j < sto; j++) {         // Перебор столбцов
		mn = min(j, sto - j - 1);     // Определение ширины ромба для столбца j
		indent_min = (str / 2 - 1) - mn; // Верхняя граница ромба
		indent_max = (str / 2) + mn;     // Нижняя граница ромба

		// Обнуление чисел, находящихся вне зоны сортировки
		for (int i = 0; i < indent_min; i++) {
			*(*(a + i) + j) = 0;
		}
		for (int i = indent_max + 1; i < str; i++) {
			*(*(a + i) + j) = 0;
		}
	}
}

int min(int a, int b) {
	if (a < b)
		return a;
	else
		return b;
}

void sort_obmenF(matrix a, int str, int sto) {
	int i, j, k, mn, indent_min, indent_max;
	num z;
	for (j = 0; j < sto; j++) {          // Перебор столбцов
		mn = min(j, sto - j - 1);     // Определение ширины ромба для столбца j
		indent_min = (str / 2 - 1) - mn; // Верхняя граница ромба
		indent_max = (str / 2) + mn;     // Нижняя граница ромба

		/* Пузырьковая сортировка по возрастанию внутри ромба(убывание по мере продвижения вверх
		по матрице это то же самое, что возрастание по мере продвижения вниз, а потому, несмотря на то,
		что алгоритм другой, результирующая матрица получится абсолютно той же самой) */
		for (k = indent_max - 1; k > indent_min - 1; k--) {
			for (i = indent_min; i < indent_max; i++) {
				// Сравниваем текущий элемент со следующим и меняем элементы местами, если текущий больше
				if (*(*(a + i) + j) > *(*(a + i + 1) + j)) {
					z = *(*(a + i) + j);
					*(*(a + i) + j) = *(*(a + i + 1) + j);
					*(*(a + i + 1) + j) = z;
				}
			}
		}
	}
	return;
}

//вывод матрицы
void outputmatr(matrix a, int str, int sto)
{
	int i, j;
	for (i = 0; i < str; i++) {
		for (j = 0; j < sto; j++) {
			cout.width(2); // ширина поля для выводимого параметра
			cout << *(*(a + i) + j) << ' ';
		}
		cout << '\n';
	}
}
sort_obmenF